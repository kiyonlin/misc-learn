# 风格指南
## 单一职责
对所有的组件、服务等等应用[***单一职责原则 (SRP)***](https://wikipedia.org/wiki/Single_responsibility_principle)

### 单一规则
坚持每个文件只定义一样东西（例如服务或组件），考虑把文件大小限制在 400 行代码以内。
- 单组件文件非常容易阅读、维护，并能防止在版本控制系统里与团队冲突。
- 单组件文件可以防止一些隐蔽的程序缺陷，当把多个组件合写在同一个文件中时，可能造成共享变量、创建意外的闭包，或者与依赖之间产生意外耦合等情况。
- 单独的组件通常是该文件默认的导出，可以用路由器实现按需加载。
- 增强代码可重用性和阅读性，减少出错的可能性。

### 小函数
坚持定义简单函数，考虑限制在 75 行之内。
- 简单函数更易于测试，特别是当它们只做一件事，只为一个目的服务时。
- 简单函数促进代码重用。
- 简单函数更易于阅读。
- 简单函数更易于维护。
- 简单函数可避免易在大函数中产生的隐蔽性错误，例如与外界共享变量、创建意外的闭包或与依赖之间产生意外耦合等。

## 命名
命名约定对可维护性和可读性非常重要。

### 总体命名原则

坚持所有符号使用一致的命名规则。

坚持遵循同一个模式来描述符号的特性和类型。推荐的模式为 `feature.type.ts`。

- 命名约定提供了一致的方式来查找内容，让你一眼就能找到。 项目的一致性是至关重要的。团队内的一致性也很重要。整个公司的一致性会提供惊人的效率。
- 命名约定帮助你更快得找到想找的代码，也更容易理解它。
- 目录名和文件名应该清楚的传递它们的意图。 例如，`app/heroes/hero-list.component.ts` 包含了一个用来管理英雄列表的组件。

### 使用点和横杠来分隔文件名

坚持 在描述性名字中，用横杠来分隔单词。

坚持使用点来分隔描述性名字和类型。

坚持遵循先描述组件特性，再描述它的类型的模式，对所有组件使用一致的类型命名规则。推荐的模式为 `feature.type.ts`。

坚持使用惯用的后缀来描述类型，包括 `*.service`、`*.component`、`*.pipe`、`*.module`、`*.directive`。 必要时可以创建更多类型名，但必须注意，不要创建太多。

- 类型名字提供一致的方式来快速的识别文件中有什么。
-  利用编辑器或者 IDE 的模糊搜索功能，可以很容易地找到特定文件。
-  像 `.service` 这样的没有简写过的类型名字，描述清楚，毫不含糊。 像 `.srv`, `.svc`, 和 `.serv` 这样的简写可能令人困惑。
- 为自动化任务提供模式匹配。

### 符号名与文件名

坚持为所有东西使用一致的命名约定，以它们所代表的东西命名。

坚持使用大写驼峰命名法来命名类。符号名匹配它所在的文件名。

坚持在符号名后面追加约定的类型后缀（例如 `Component`、`Directive`、`Module`、`Pipe`、`Service`）。

坚持在符号名后面追加约定的类型后缀（例如 `.component.ts`、`.directive.ts`、`.module.ts`、`.pipe.ts`、`.service.ts`）。

坚持在文件名后面追加约定的类型后缀（例如 `.component.ts`、`.directive.ts`、`.module.ts`、`.pipe.ts`、`.service.ts`）。

- 遵循一致的约定可以快速识别和引用不同类型的资产。

### 服务名

坚持使用一致的规则命名服务，以它们的特性来命名。

坚持为服务的类名加上 `Service` 后缀。 例如，获取数据或英雄列表的服务应该命名为 `DataService` 或 `HeroService`。

有些词汇显然就是服务，比如那些以“-er”后缀结尾的。比如把记日志的服务命名为 `Logger` 就比 `LoggerService` 更好些。需要在你的项目中决定这种特例是否可以接受。 但无论如何，都要尽量保持一致。

- 提供一致的方式来快速识别和引用服务。
- 像 Logger 这样的清楚的服务名不需要后缀。
- 像 Credit 这样的，服务名是名词，需要一个后缀。当不能明显分辨它是服务还是其它东西时，应该添加后缀。

### 引导

坚持把应用的引导程序和平台相关的逻辑放到名为 `main.ts` 的文件里。

坚持在引导逻辑中包含错误处理代码。

避免把应用逻辑放在 `main.ts` 中，而应放在组件或服务里。

- 应用的启动逻辑遵循一致的约定。
- 这是从其它技术平台借鉴的常用约定。